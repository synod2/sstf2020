decryptData 1
-------------

문제의 암호문 (106바이트)

```
1b4eb59dce68c7d5173871ff3211a35bc8d089147c0c4c0f7cdf1b9489d4a640ee173557778095d84d0cd344e213100f2923e8ea96
```

문제에서 주어진 코드에 따라 조건을 정리하자.

1. 키는 40글자짜리 랜덤 숫자로 생성됨.
2. 문자열의 앞 16글자는 17bit LFSR에서 솔트로 사용된다. 
3. 문자열의 뒤 24글자는 25bit LFSR에서 솔트로 사용된다. 
4. 매 LFSR.clock()을 거친 문자열들을 xor 연산하여 키 스트림으로 사용한다. 
5. 키 스트림은 매 반복마다 왼쪽으로 시프트 연산(2배씩 커짐) 후 클록 연산 결과와 OR 연산된다. 
6. 출력 데이터는 데이터에 연산 결과 키스트림을 xor한 결과값이다. 
7. 평문은 "The flag is:" 라는 문자열로 시작한다. 

암호화 알고리즘을 분석하여 그대로 역 연산하면 결과값을 도출해 낼수 있는 문제. 
알고리즘을 분석해보자.

1. 총 40비트 key중 앞 16비트와 뒤 24비트를 분리해 각각 LFSR의 솔트로 사용함. 
2. LFSR 내에서 register는 솔트의 하위 3비트를 날리고 비트를 더 추가하여 1010 을 넣는 연산을 한다. 
3. clock이 돌때마다 실행되며 reduce함수를 이용해 결과값을 도출해낸다. 
   ```reduce(집계 함수, 순회 가능한 데이터[, 초기값]) ``` 
  4. reduce에서 x와 y를 xor한 연산 결과를 x에 넣으면서 누적 연산을 진행한다. 
     - 누적 연산에서는 내부적으로 for문이 돌면서 아까 생성한 register를 오른쪽 시프트 후 1과 and 연산 진행한다.  이렇게 나오면 output 결과는 0 아니면 1이 된다. 
  5. register는 우측 시프트 연산을 거치고 , output과 연산을 거치며 변경된다. 
  6. output결과는 LFSR17의 경우는true, 25의 경우는 false와 XOR 연산되어 최종 출력으로 나간다. 
7. keystream은 데이터 길이 * 8 회 만큼 반복문을 도는데, 한번 돌 때마다 좌측으로 시프트 연산 후, lfst17 와 25의 xor 연산 결과와 and 연산을 거친다. -> 즉, 8번 돌면서 8비트를 구성해 한글자씩 글자를 만드는 것. 
8. 즉, 5바이트짜리 숫자를 만들고 2바이트 , 3바이트로 쪼갠 다음 연산을 진행하여 17비트, 25비트짜리 키 스트림 두개를 생성한 다음, 1비트씩 연산 후 결과를 만들어 최종 암호문을 완성한다는 것.

이때 이미 암호화 결과값을 가지고 있으므로 , 키 5바이트 중 앞 2바이트를 무작위로 찾아내면 나머지 뒷 3바이트는 역연산을 통해 찾아낼 수 있다.  

왜냐하면, 암호문 = 평문 ^ lfsr17 ^ lfsr25 인데, 평문의 앞 12바이트는 알고 있으므로 25비트만큼은 찾아낼 수 있고 XOR 연산만 거꾸로 돌리면  lfsr 25비트를 만들어낼 수 있다. 

이렇게 찾아낸 lfsr 25비트 스트림은 lfsr25의 첫 25비트 레지스터와 같다. 25회 이상의 연산을 돌때부턴 이미 만들어낸 레지스터에 덧씌울것이기 때문. 따라서 그 키 스트림으로 찾은 레지스터를 그대로 하여 clock 연산을 마저 진행해도 결과는 동일할 것이다.  굳이 원본 키를 안찾아내도 된다는 소리. 

이제 아까 찾은 2바이트 키가 맞는지를 검증하는 방법인데, 찾은 키 스트림을 이용해 미리 주어진 문자열 "The flag is:" 을 암호화 한 결과의 25비트 이후부터가 원본 비트와 동일하면 해당 키가 맞는것이다. 

코드를 한번 짜보자. 

일단 무작위로 1~16사이 숫자를 하나 만들고, 그 숫자를 가지고 LFSR을 거쳐 키 스트림을 만들어낸 다음,  만들어낸 키 스트림과 평문에서 잘라낸 25비트, 암호문 결과의 25비트를 xor 연산시켜 스트림2를 찾자. 

찾아낸 스트림 2의 일부를 레지스터로 그대로 사용하여 lfsr2 의 전체 스트림을 만들어내고,  그렇게 만들어낸 두 스트림을 가지고 12바이트 평문 전체를 암호화 한 결과가 암호문의 첫 24바이트와 일치하는지 판독해야한다. 

24바이트까지는 평문을 암호화한 결과가 암호문과 일치하는지를 비교할 수 있었으니, 24바이트 이후부터는 암호문을 복호화한 결과가 평문이 나오는지를 찾아야한다. 연산에 의한 오차를 최대한 줄이기 위해 한비트씩 연산해보자.  연산 결과가 평문과 일치하지 않으면 멈추고, 그렇지 않다면 계속 진행시킨다. 

검사하는 암호문의 비트가 평문 전체 비트보다 작을 때 연산결과가 일치하지 않으면 틀린것이라고 판독할 수 있는데, 검사 비트 길이가 평문을 넘어갔을 경우부터는 이전의 결과가 모두 일치한 셈이므로, 그 뒤부터는 진짜 평문을 찾아내는 과정이라고 생각할 수 있다. 

